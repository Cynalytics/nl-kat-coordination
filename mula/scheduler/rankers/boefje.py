import random
import statistics
from datetime import datetime, timedelta, timezone
from typing import Any, List

from scheduler import models

from .ranker import Ranker


class BoefjeRanker(Ranker):
    MAX_PRIORITY = 1000
    MAX_DAYS = 7

    def rank(self, obj: Any) -> int:
        """When a task hasn't run in a while it needs to be run sooner. We want
        a task to get a priority of 3 when `max_days` days are gone by, and
        thus it should have a lower bound of 3 for every task that has run past
        those`max_days`.

        3 has been chosen as a lower bound because new tasks that have not yet
        run before will get the priority of 2. And tasks created by the user
        (from rocky) will get a priority of 1.

        Before the end of those `max_days` we want to prioritize a task within
        a range from 3 to the maximum value of `max_priority`.
        """
        max_priority = self.MAX_PRIORITY
        max_days_in_seconds = self.MAX_DAYS * (60 * 60 * 24)
        grace_period = timedelta(seconds=self.ctx.config.pq_populate_grace_period)

        prior_tasks: List[models.Task] = self.ctx.task_store.get_tasks_by_hash(obj.hash)

        # New tasks that have not yet run before
        if prior_tasks is None or not prior_tasks:
            return 2

        # Make sure that we don't have tasks that are still in the grace period
        time_since_grace_period = ((datetime.now(timezone.utc) - prior_tasks[0].modified_at) - grace_period).seconds
        if time_since_grace_period < 0:
            return -1

        if time_since_grace_period >= max_days_in_seconds:
            return 3

        # Calculate the score based on the duration, number of objects, number
        # of findings and the priority of the prior tasks.
        freq_duration, freq_objects, freq_findings, freq_priorities = [], [], [], []

        # Iterate over the prior tasks
        for prior_task in prior_tasks:
            # How long did it take for the task to run?
            duration = (prior_task.modified_at - prior_task.started_at).seconds
            freq_duration.append(duration)
            self.logger.info(duration)

            # How many objects where created by the task?
            children = self.ctx.services.octopoes.get_children_by_ooi(
                organisation_id=obj.organisation_id,
                reference=prior_task.input_ooi.reference,
            )
            freq_objects.append(len(children))
            self.logger.info(children)

            # How many findings were generated by the task?
            findings = self.ctx.services.octopoes.get_findings_by_ooi(
                organisation_id=obj.organisation_id,
                reference=prior_task.input_ooi.reference,
            )
            freq_findings.append(len(findings))
            self.logger.info(findings)

            # What were the prior priorities of the task?
            freq_priorities.append(prior_task.priority)
            self.logger.info(prior_task.priority)

        min_duration = min(freq_duration)
        max_duration = max(freq_duration)
        median_duration = statistics.median(freq_duration)
        msg = f"min_duration: {min_duration}, max_duration: {max_duration}, median_duration: {median_duration}"
        self.logger.info(msg)

        min_objects = min(freq_objects)
        max_objects = max(freq_objects)
        median_objects = statistics.median(freq_objects)
        msg = f"min_objects: {min_objects}, max_objects: {max_objects}, median_objects: {median_objects}"
        self.logger.info(msg)

        min_findings = min(freq_findings)
        max_findings = max(freq_findings)
        median_findings = statistics.median(freq_findings)
        msg = f"min_findings: {min_findings}, max_findings: {max_findings}, median_findings: {median_findings}"
        self.logger.info(msg)

        min_priorities = min(freq_priorities)
        max_priorities = max(freq_priorities)
        mean_priorities = statistics.mean(freq_priorities)
        msg = f"min_priorities: {min_priorities}, max_priorities: {max_priorities}, mean_priorities: {mean_priorities}"
        self.logger.info(msg)

        # Normalize the values
        duration = (median_duration - min_duration) / (max_duration - min_duration)
        objects = (median_objects - min_objects) / (max_objects - min_objects)
        findings = (median_findings - min_findings) / (max_findings - min_findings)
        priorities = (mean_priorities - min_priorities) / (max_priorities - min_priorities)
        since_grace_period = min((time_since_grace_period - 0) / (max_days_in_seconds - 0), 1)
        msg = f"""duration: {duration},
        objects: {objects},
        findings: {findings},
        priorities: {priorities},
        since_grace_period: {since_grace_period}"""
        self.logger.info(msg)

        # Weights for the normalized values
        weights = {
            "duration": 0.2,
            "objects": 0.2,
            "findings": 0.2,
            "priorities": 0.2,
            "since_grace_period": 0.2,
        }

        # Calculate the score, by multiplying the normalized values with the
        # weights and adding them together. Then multiply the score with the
        # max_priority to get the priority.
        score = (
            duration * weights["duration"]
            + objects * weights["objects"]
            + findings * weights["findings"]
            + priorities * weights["priorities"]
            + since_grace_period * weights["since_grace_period"]
        ) * max_priority

        self.logger.info("score: %s", score)

        return int(score)


class BoefjeRankerTimeBased(Ranker):
    """A timed-based BoefjeRanker allows for a specific time to be set for the
    task to be ranked. You'll be able to rank jobs with a specific time
    element. Epoch time is used allows the score and used as the priority on
    the priority queue. This allows for time-based scheduling of jobs.
    """

    def rank(self, obj: Any) -> int:
        minimum = datetime.today() + timedelta(days=1)
        maximum = minimum + timedelta(days=7)
        return random.randint(int(minimum.timestamp()), int(maximum.timestamp()))
