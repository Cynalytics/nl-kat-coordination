import random
import statistics
from datetime import datetime, timedelta, timezone
from typing import Any, List

from scheduler import models

from .ranker import Ranker


class BoefjeRanker(Ranker):
    MAX_PRIORITY = 1000
    MAX_DAYS = 7

    def rank(self, obj: Any) -> int:
        """When a task hasn't run in a while it needs to be run sooner. We want
        a task to get a priority of 3 when `max_days` days are gone by, and
        thus it should have a lower bound of 3 for every task that has run past
        those`max_days`.

        3 has been chosen as a lower bound because new tasks that have not yet
        run before will get the priority of 2. And tasks created by the user
        (from rocky) will get a priority of 1.

        Before the end of those `max_days` we want to prioritize a task within
        a range from 3 to the maximum value of `max_priority`.
        """
        max_priority = self.MAX_PRIORITY
        max_days_in_seconds = self.MAX_DAYS * (60 * 60 * 24)
        grace_period = timedelta(seconds=self.ctx.config.pq_populate_grace_period)

        # TODO: only that are finished, do we need to count the failures?
        prior_tasks: List[models.Task] = self.ctx.task_store.get_tasks_by_hash(obj.hash)

        # New tasks that have not yet run before
        if prior_tasks is None or not prior_tasks:
            return 2

        # Make sure that we don't have tasks that are still in the grace period
        time_since_grace_period = ((datetime.now(timezone.utc) - prior_tasks[0].modified_at) - grace_period).seconds
        if time_since_grace_period < 0:
            return -1

        # When tasks are older than the grace period, we want to give them a
        # priority of 3.
        if time_since_grace_period >= max_days_in_seconds:
            return 3

        # Calculate the score based on the duration, number of objects, number
        # of findings and the priority of the prior tasks.
        freq_duration, freq_objects, freq_findings, freq_priorities = [], [], [], []

        # Iterate over the prior tasks
        for prior_task in prior_tasks:
            # How long did it take for the task to run?
            duration = (prior_task.modified_at - prior_task.created_at).seconds
            freq_duration.append(duration)
            self.logger.info(duration)

            # How many objects where created by the task?
            objects = self.ctx.services.octopoes.get_objects_by_ooi(
                organisation_id=obj.organization,
                reference=prior_task.p_item.data.get("input_ooi"),
            )
            freq_objects.append(len(objects))
            self.logger.info(objects)

            # How many findings were generated by the task?
            findings = self.ctx.services.octopoes.get_findings_by_ooi(
                organisation_id=obj.organization,
                reference=prior_task.p_item.data.get("input_ooi"),
            )
            freq_findings.append(len(findings))
            self.logger.info(findings)

            # What were the prior priorities of the task?
            freq_priorities.append(prior_task.p_item.priority)
            self.logger.info(prior_task.p_item.priority)

        min_duration = min(freq_duration)
        max_duration = max(freq_duration)
        median_duration = statistics.median(freq_duration)

        self.logger.info(
            "min_duration: %s, max_duration: %s, median_duration: %s",
            min_duration,
            max_duration,
            median_duration,
        )

        min_objects = min(freq_objects)
        max_objects = max(freq_objects)
        median_objects = statistics.median(freq_objects)

        self.logger.info(
            "min_objects: %s, max_objects: %s, median_objects: %s",
            min_objects,
            max_objects,
            median_objects,
        )

        min_findings = min(freq_findings)
        max_findings = max(freq_findings)
        median_findings = statistics.median(freq_findings)

        self.logger.info(
            "min_findings: %s, max_findings: %s, median_findings: %s",
            min_findings,
            max_findings,
            median_findings,
        )

        min_priorities = min(freq_priorities)
        max_priorities = max(freq_priorities)
        mean_priorities = statistics.mean(freq_priorities)

        self.logger.info(
            "min_priorities: %s, max_priorities: %s, mean_priorities: %s",
            min_priorities,
            max_priorities,
            mean_priorities,
        )

        def division(a, b):
            return a / b if b != 0 else 0

        # Normalize the values
        duration = division((median_duration - min_duration), (max_duration - min_duration))
        objects = division((median_objects - min_objects), (max_objects - min_objects))
        findings = division((median_findings - min_findings), (max_findings - min_findings))
        priorities = division((mean_priorities - min_priorities), (max_priorities - min_priorities))
        since_grace_period = min(division((time_since_grace_period - 0), (max_days_in_seconds - 0)), 1)

        self.logger.info(
            "duration: %s, objects: %s, findings: %s, priorities: %s, since_grace_period: %s",
            duration,
            objects,
            findings,
            priorities,
            since_grace_period,
        )

        # Weights for the normalized values
        weights = {
            "duration": 0.2,
            "objects": 0.2,
            "findings": 0.2,
            "priorities": 0.2,
            "since_grace_period": 0.2,
        }

        # Calculate the score, by multiplying the normalized values with the
        # weights and adding them together. Then multiply the score with the
        # max_priority to get the priority.
        score = (
            duration * weights["duration"]
            + objects * weights["objects"]
            + findings * weights["findings"]
            + priorities * weights["priorities"]
            + since_grace_period * weights["since_grace_period"]
        ) * max_priority

        self.logger.info("score: %s", score)

        return int(score)


class BoefjeRankerTimeBased(Ranker):
    """A timed-based BoefjeRanker allows for a specific time to be set for the
    task to be ranked. You'll be able to rank jobs with a specific time
    element. Epoch time is used allows the score and used as the priority on
    the priority queue. This allows for time-based scheduling of jobs.
    """

    def rank(self, obj: Any) -> int:
        minimum = datetime.today() + timedelta(days=1)
        maximum = minimum + timedelta(days=7)
        return random.randint(int(minimum.timestamp()), int(maximum.timestamp()))
