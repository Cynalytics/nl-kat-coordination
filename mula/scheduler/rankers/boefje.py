import math
import random
import statistics
from datetime import datetime, timedelta, timezone
from typing import Any, List

from scheduler import models

from .ranker import Ranker


class BoefjeRanker(Ranker):
    """The BoefjeRanker is a ranker that is used to rank tasks based on the
    procedure listed in the `rank()` method.
    """

    MAX_PRIORITY = 1000
    MAX_DAYS = 7

    def rank(self, obj: Any) -> int:
        """When a task hasn't run in a while it needs to be run sooner. We want
        a task to get a priority of 3 when `max_days` days are gone by, and
        thus it should have a lower bound of 3 for every task that has run past
        those`max_days`.

        3 has been chosen as a lower bound because new tasks that have not yet
        run before will get the priority of 2. And tasks created by the user
        (from rocky) will get a priority of 1.

        Before the end of those `max_days` we want to prioritize a task within
        a range from 3 to the maximum value of `max_priority`.
        """
        max_priority = self.MAX_PRIORITY
        max_days_in_seconds = self.MAX_DAYS * (60 * 60 * 24)
        grace_period = timedelta(seconds=self.ctx.config.pq_grace_period)

        prior_tasks: List[models.Task] = self.ctx.datastores.task_store.get_tasks_by_hash(obj.hash)

        # New tasks that have not yet run before
        if prior_tasks is None or not prior_tasks:
            return 2

        # Make sure that we don't have tasks that are still in the grace period
        time_since_grace_period = ((datetime.now(timezone.utc) - prior_tasks[0].modified_at) - grace_period).seconds
        if time_since_grace_period < 0:
            return -1

        # When tasks are older than the grace period, we want to give them a
        # priority of 3.
        if time_since_grace_period >= max_days_in_seconds:
            return 3

        # Calculate the score based on the duration, number of objects, number
        # of findings and the priority of the prior tasks.
        freq_duration, freq_objects, freq_findings, freq_priorities = [], [], [], []

        # Iterate over the prior tasks
        for prior_task in prior_tasks:
            # How long did it take for the task to run?
            duration = (prior_task.modified_at - prior_task.created_at).seconds
            freq_duration.append(duration)
            self.logger.info(duration)

            # How many objects where created by the task?
            objects = self.ctx.services.octopoes.get_objects_by_ooi(
                organisation_id=obj.organization,
                reference=prior_task.p_item.data.get("input_ooi"),
            )
            freq_objects.append(len(objects))
            self.logger.info(objects)

            # How many objects where created by the task?
            # How many findings were generated by the task?
            findings = self.ctx.services.octopoes.get_findings_by_ooi(
                organisation_id=obj.organization,
                reference=prior_task.p_item.data.get("input_ooi"),
            )
            freq_findings.append(len(findings))
            self.logger.info(findings)

            # What were the prior priorities of the task?
            priority = prior_task.p_item.priority
            if priority is None:
                priority = random.randint(1, max_priority)
            freq_priorities.append(prior_task.p_item.priority)
            self.logger.info(prior_task.p_item.priority)

        if not any([freq_duration, freq_objects, freq_findings, freq_priorities]):
            return -1

        max_duration: int = max(freq_duration)
        min_duration: int = min(freq_duration)
        med_duration: float = statistics.median(freq_duration)

        min_objects: int = min(freq_objects)
        max_objects: int = max(freq_objects)
        med_objects: float = statistics.median(freq_objects)

        min_findings: int = min(freq_findings)
        max_findings: int = max(freq_findings)
        med_findings: float = statistics.median(freq_findings)

        min_priorities: int = min(freq_priorities)
        max_priorities: int = max(freq_priorities)
        med_priorities: float = statistics.median(freq_priorities)

        def division(a, b):
            return a / b if b != 0 else 0

        # Normalize the values
        norm_duration: float = division((med_duration - min_duration), (max_duration - min_duration))
        norm_objects: float = division((med_objects - min_objects), (max_objects - min_objects))
        norm_findings: float = division((med_findings - min_findings), (max_findings - min_findings))
        norm_priorities: float = division((med_priorities - min_priorities), (max_priorities - min_priorities))
        norm_since_grace_period: float = min(division((time_since_grace_period - 0), (max_days_in_seconds - 0)), 1)

        # Weights for the normalized values
        weights = {
            "duration": 0.2,
            "objects": 0.2,
            "findings": 0.2,
            "priorities": 0.2,
            "since_grace_period": 0.2,
        }

        # Calculate the score, by multiplying the normalized values with the
        # weights and adding them together. Then multiply the score with the
        # max_priority to get the priority.
        score: float = (
            norm_duration * weights["duration"]
            + norm_objects * weights["objects"]
            + norm_findings * weights["findings"]
            + norm_priorities * weights["priorities"]
            + norm_since_grace_period * weights["since_grace_period"]
        ) * max_priority

        self.logger.info("score: %s", score)

        return int(math.ceil(max(score, 1)))


class BoefjeRankerTimeBased(Ranker):
    """A timed-based BoefjeRanker allows for a specific time to be set for the
    task to be ranked. You'll be able to rank jobs with a specific time
    element. Epoch time is used allows the score and used as the priority on
    the priority queue. This allows for time-based scheduling of jobs.
    """

    def rank(self, obj: Any) -> int:
        minimum = datetime.today() + timedelta(days=1)
        maximum = minimum + timedelta(days=7)
        return random.randint(int(minimum.timestamp()), int(maximum.timestamp()))
